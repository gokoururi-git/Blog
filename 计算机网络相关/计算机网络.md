## 计算机网络体系结构

**因特网协议栈：**

应用层：FTP、SMTP、HTTP

传输层：TCP、UDP

网络层：IP、routing protocol

链路层：Ethernet、802.II（WiFi）、PPP

物理层：bits ”on the wire“

> 用户功能：应用层、**运输层**
>
> 面向通讯的功能：**运输层**、网络层、数据链路层、物理层

**ISO/OSI 参考模型**：应用层、表示层、会话层、传输层、网络层、链路层、物理层

> 实体：表示任何可发送或接收信息的硬件或软件进程。
>
> 服务访问点：同一系统相邻两层的实体进行交互的地方

# 应用层

## C/S模式

**客户**和**服务器**都指通讯中涉及的两个**应用进程**

服务器

- 一直在线
- 固定的IP，不需要知道客户的ip

客户端

- 主动向服务器发起通信
- 可能使用动态IP
- 不与其他客户机直接通讯

建立连接之后通讯可以双向通讯

## Socket

进程间通信利用套接字(Socket）发送和接受消息来实现。（包括一台电脑的进程间通讯和多台电脑之间进程通讯）、

应用进程通过套接字接入网络

进程的寻址：IP+端口号

## P2P（peer to peer）

- 没有永远在线的服务器
- 终端之间直接通讯
- 具有P2P架构的应用程序具有客户端进程和服务器进程

## SSL（secure socket layer）

一般的TCP不提供安全机制，我们通过应用层协议SSL提供安全机制

## HTTP(Hypertext Transfer Protocol)

是一种基于web的应用层协议、使用TCP提供的服务、他是一种**无状态协议**

### 往返时延(RTT)

从客户机发送请求开始到服务器返回第一个分组（注意分组不是应用层的概念）的过程。

非持续连接http响应时间 = 发起、建立TCP连接的一个RTT + 发送HTTP请求消息到HTTP的一个分组到达所需RTT、文件发送时延（2RTT+文件发送时延）

### HTTP连接类型

#### 非持续连接HTTP

- 每个TCP连接最多发送一个对象，然后关闭连接
- 多个对象需要多个TCP连接
- HTTP1.0
- 缺点：每个对象需要2RTT、OS建立TCP连接开销资源

#### 持续链接HTTP

- 单个TCP连接可以传输多个对象
- HTTP1.1
- 整个过程只需要1个RTT+文件传输时延

> 非流水式：请求串行
>
> 流水式：请求并发

### HTTP状态码

- 1xx：请求收到了或者正在处理
- 2xx：表示成功
- 3xx：表示重定向
- 4xx：400：请求错误、404：资源未找到
- 5xx：服务器错误：505：HTTP版本不支持

状态码相关一个有趣的网站：

usage: https://http.cat/[status code]

### 代理服务器实现缓存

代理请求并且缓存下来，一般由ISP架设

## SMTP

Email消息传输/交换协议，用来交付/存储至接收方服务器，支持用户代理向服务器发送，但是不支持向用户代理发送

邮件访问协议：

- POP
- IMAP
- HTTP

![image-20210109184004820](.\images\image-20210109184004820.png)

## DNS

### 域名

二级域名.权限域名.顶级域名.根域名

举例：`mail.qq.com[.root]`

其中`.root`可以忽略为`.`，更可以忽略不写

![image-20210109185242551](.\images\image-20210109185242551.png)

每个ISP有一个本地域名服务器

迭代查询：

![image-20210109185643574](.\images\image-20210109185643574.png)

递归查询

![image-20210109185743220](.\images\image-20210109185743220.png)

为了缓解根DNS服务器的压力，每个域名服务器都设有缓存，缓存 在一定时间之后消失

### DNS攻击

**DDoS攻击**

**重定向攻击**

# 传输层

从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。

**传输层的作用**：为网络层传来的数据寻路具体应用（根据端口）

两个对等运输实体在通信时传送的数据单位叫**运输协议数据单元**(TPDU)

TCP传送的数据单位协议是**TCP报文段**(segment)。

UDP传送的数据单位协议是**UDP报文**或**用户数据报**。

**在实际情况：**

客户端采用动态端口，在传送的时候将这个动态端口传给服务器，这样一来从服务器传来的IP数据包就有能力判断是哪个进程的了，这样就解决了各平台应用的端口的不统一问题。

## UDP

只在IP的数据报服务上增加了很少一点功能：

1. 复用和分用
2. 差错检测

**主要特点**

1. UDP是无连接的，发送数据前不需要建立连接

2. UDP使用尽最大努力交付

3. UDP面向报文：发送方UDP对应用层交下来的报文既不合并也不拆分，只保留报文的边界；接收方UDP对网络层传来的数据包只去除首部就交给应用层。鉴于此，应用程序必须选择合适大小的报文。

   ![image-20210109205800109](.\images\image-20210109205800109.png)

### UDP首部格式

   由源端口（2Byte），目的端口（2Byte），长度（2Byte），校验和（2Byte）组成

   虽然在UDP之间的通信要用到端口号，但由于UDP的通信是无连接的，因此不需要使用套接字来建立连接。

   **UDP校验和**

   计算时临时把12字节的“伪首部”和UDP用户数据包连接在一起。

## TCP

TCP是面向连接的运输层协议，在无连接、不可靠的IP网络服务基础上提供可靠交互的服务。

**特点**

- 面向连接
- 一对一
- 提供可靠交付
- 提供全双工
- 面向字节流

TCP不关心应用进程一次把多长的报文发送到TCP缓存。

TCP对连续的字节流进行分段，形成TCP报文段。

TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应该包含多少个字节。

**TCP的连接**

TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口。**TCP连接的端点叫做套接字(socket)或插口。**

端口号拼接到(contatenated with)IP地址即构成了**套接字**。

### 停止等待协议

每发送玩一个分组就停止发送，等待对方确认。收到确认之后在发送下一个分组。

接收方接受到一个包出错时，丢弃它，什么都不干（不通知发送方有错），或者一个包在传输过程中丢失了，接收方也什么都不做。

发送方一段时间后发现没有ack返回，重新发送。

![image-20210109222356760](.\images\image-20210109222356760.png)

一些问题：

- 接受重复怎么找出重复的丢弃呢：对分组编号。
- ack丢失、迟到怎么办：发送方延迟重传，接收方先发送每一个重复分组的ack之后舍弃重复分组。（不能认为对一个分组的ack已经发送过了就不用再发了）

注意：ack也需要编号

> 像上述的这种可靠传输协议常称为自动重传请求ARQ (Automatic Repeat request)。意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。

优点是简单，缺点是信道利用率太低。

![image-20210109223907587](.\images\image-20210109223907587.png)

![image-20210109224013123](.\images\image-20210109224013123.png)

### 连续ARQ协议

基本思想:

发送方一次可以发出多个分组。

使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。

每收到一个确认，发送方就把发送窗口向前滑动。接收方一般采用**累积确认**的方式。

> 累积确认：接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示:到这个分组为止的所有分组都已正确收到了。

采用回退N (Go-Back-N)方法进行重传。

> Go-back-N（回退N)：表示需要再退回来重传已发送过的N个分组。

每个链接有4个窗口

### TCP报文段

TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能都体现在它首部中各字段的作用。

TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项(n是整数)。因此**TCP首部的最小长度是20字节。**

和UDP一样，在计算检验和时，临时把12字节的“伪首部”和TCP报文段连接在一起。伪首部仅仅是为了计算检验和。起。伪首部仅仅是为了计算检验和。

MSS (Maximum Segment Size)是TCP报文段中的**数据字段**的最大长度。


# HTTP2.0


