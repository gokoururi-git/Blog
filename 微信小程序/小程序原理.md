小程序的架构方案：

![640](./images/640.webp)

整个小程序由两个 webview 组成，代码分为 UI 层和逻辑层。UI 层运行在第一个 WebView 当中，执行 DOM 操作和交互事件的响应，里面是 WAWebview.js 代码及编译后的内容。逻辑层执行在（第二个webview 中）独立的 JS 引擎中（iOS：JavaScriptCore, android：X5 JS解析器；统称 JSCore；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。

当我们对 view 层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层。View 渲染更新视图。

#### 架构的讨论

微信的这种架构，对逻辑和UI进行了完全隔离，小程序逻辑和UI完全运行在2个独立的Webview里面来处理。那么这么做的好处是啥？总感觉更加麻烦了。除了小程序外，还有人采用这种架构设计么？

在网上搜索了一下，目前使用这种架构的项目还真有一个：去哪儿最新的 YIS 框架

> YIS 采取了类似小程序的架构，分为逻辑层和UI层。UI 层运行在 WebView 中，而逻辑层运行在独立的 JS 引擎中。相应地，整个应用的代码，也分为两个大的部分，一部分运行在 WebView 中，一部分运行在JS引擎中。JS引擎计算DOM结构输出给WebView，WebView转发用户的点击事件给JS引擎。

该项目做法和小城十分类似，唯一缺少的就是没有 native 的组件吧。然而官方文档上也没有任何介绍，为什么要这么做，只是说更流畅了。

#### 一些看法

传统 web 页面显示需要经历一下几个步骤:

- webview 初始化
- 加载 HTML, CSS, JS
- 编译 JS
- Render 计算
- DOM Path

而利用小程序架构后，我们就可以将上述过程拆解成两部分并行执行： webview 部分：

- webview 初始化
- 加载 HTML，CSS, JS (经过拆分后，体积大幅度减小)
- 编译 JS
- 等待页面需要的数据
- 反序列化数据
- 执行 Patch
- 渲染页面
- 等待更多消息

jscore 部分：

- 初始化
- 加载框架 js 代码
- 编译 js
- 加载业务逻辑 js 代码
- 编译 js
- 计算首屏虚拟 DOM 结构
- 序列化数据，传输
- 等待 webview 消息，或者 Native 消息

这样渲染进程和逻辑进程分离，并行处理：加速首屏渲染速度；避免单线程模型下，js 运算时间过长，UI 出现卡顿。 完全采用数据驱动的方式，不能直接操作 DOM，避免低质量的代码。 webview 和 jscore 可以预

当然这种架构方案也有这一定的缺点：

- 不能灵活操作 DOM，无法实现较为复杂的爱的暖效果
- 部分和 NA 相关的视图有使用限制，如微信的 scrollView 内不能有 textarea。
- 页面大小、打开页面数量都受到限制
- 需要单独开发适配，不能复用现有代码资源。