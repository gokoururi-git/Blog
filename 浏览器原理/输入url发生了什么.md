# 输入URL发生了什么

1. 浏览器进程获取url，接下来通过进程间通讯将URL发送给网络进程

2. 网络进程查找DNS

   - 本地缓存查找DNS缓存

     失败：

     - 本地HOST查找DNS

       失败：

       - DNS服务器查找DNS：具体：首先访问本地域名服务器，本地域名服务器进行顺序为`根域名服务器->顶级域名服务器->权限域名服务器`的迭代查询找到对应的ip地址

3. 如果是Https

   1. 浏览器向服务器发送自己支持的加密规则和一个随机数1

   2. 服务器收到加密规则之后选择一个，之后把选择的加密方法，证书，还有服务器生成的随机数2传回浏览器

   3. 浏览器检查证书是否有效，无效进行弹窗提示，有效用**服务端的公钥**（在证书里）加密一个新的随机数3发送给服务端

      > 随机数3是根据随机数1和随机数2算出来的

   4. 服务端收到随机数3的密文之后，用自己的私钥解密得到随机数3

   5. 此时浏览器、服务器都知道了这三个随机数，之后通过约定的加密方法各自生成以后的对称加密秘钥

      > 总流程概述
      >
      > 协商加密方法（浏览器服务器每人生成一个随机数直接透明发送）
      >
      > 协商成功之后
      >
      > 浏览器对第三个随机数进行非对称加密传输。
      >
      > 三个随机数用约定好的加密算法加密生成最终秘钥

      > 签名：服务端对即将发送报文进行一个摘要，对这个摘要进行hash计算，结果**再加密**之后就是签名

      可能会担心一个问题：我们是怎么验证浏览器收到的证书是目标服务器的证书呢？其实，服务器发来的这个证书里有两个部分，一个部分是明文信息，里面包含了服务器公钥，持有者信息，CA信息，有效期、证书编号等，第二个部分是加密了的数字签名，CA创建它的时候，证书申请方提供服务器信息，包括公钥等，然后CA使用hash函数先对前面的明文信息进行数字签名，之后使用**CA的私钥**加密这个签名，整个证书内容就完整了。浏览器验证证书的时候，就使用**CA的公钥**解密证书中加密了的数字签名，然后使用和CA相同的hash方法对明文信息进行数字签名，之后对比解密后的数字签名和自己计算得出的数字签名是否相同就能判断出证书是不是目标服务器给的。

4. 网络进程发送get请求获取资源（包含TCP建立过程，见下面）

   - 检查请求是否在资源缓存里（依据：请求方法和URL）

     在缓存里，没有过期

     - 直接返回缓存的资源

     在缓存里，但是过期了（判断过期：expires存储的过期时间 或者 cache-control存储的max-age（有效时长））

     - 发送协商缓存确认请求（拿着旧缓存的last-modified的信息放到if-modified-since里去请求服务器，或者拿着E-tag放到if-none-match里去请求服务器， **如果last-modified和E-tag都提供了那么优先E-tag**）

       确实过期了

       - 服务器返回新的资源（重新设置缓存）

       没有过期

       - 服务器返回304，更新缓存失效信息

     没在缓存里

     - 发送请求，并根据缓存策略决定要不要缓存（expires或者cache-control或者pragma，如果同时存在，优先级pragma > cache-control > expires）

     > 启发式缓存：当请求中有last-modified但是没有cache-control: max-age也没有expires，浏览器便会用返回的`(date - last-modified)*0.1`作为max-age进行缓存

   > **内存缓存：(cache from memory)**
   >
   > 随着页面进程的关闭消失，在刷新页面的时候起作用，一般不会缓存css文件，比较多地缓存js和img。
   >
   > 当内存使用率较高时浏览器优先把缓存放在磁盘
   >
   > 空间比较小
   >
   > **磁盘缓存：（cache from disk）**
   >
   > 长时间缓存
   >
   > 空间较大
   >
   > 因为IO的原因访问速度慢

   > http请求过程：【补充】！！！！！！！
   >
   > 1. 三次握手
   > 2. 传输
   > 3. 四次挥手

5. 判断有没有301、302，有的话重新发起http/https请求（http转https逻辑一般发生在这里），没有继续

6. 处理响应数据

   根据Content-Type决定怎么处理，如果是二进制，触发下载，如果是html，接着继续

7. 准备渲染进程（数据还没到渲染进程）

   首先一个页面就会启动一个渲染进程，但如果是同协议同根域名的页面会合并使用进程

8. 提交文档（这里的“文档”是指 URL 请求的响应体数据。）

   由浏览器进程发出“提交文档”的消息，渲染进程收到消息之后，会建立管道传输这个数据，当数据传输完成之后，渲染进程发出“确认提交”的消息给浏览器进程，浏览器进程收到之后更新浏览器界面**状态**（包括安全状态、URL、前进后退history）。

9. 渲染进程渲染页面

   > 需要明白一点，这一大操作的小任务都是有输入，有输出的

   1. 构建DOM树：输入HTML，输出DOM树

   2. 输出computedStyle：输入css，输出computedStyle（好像和DOM树并行执行）
      1. 初步转化为styleSheets（document.styleSheets）（不做修改，单纯构建数据结构）
      2. 将一些css单位，颜色等转化为标准形式，比如em、vh转化为px，green转化为rgb(0, 128, 0)
      3. 计算出DOM树每个节点的具体样式
         1. 计算css继承（font-size等）
         
         2. 计算层叠。
         
            >  **层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点**。
      
   3. 输出LayoutTree：输入DOM树和ComputedStyle，输出LayoutTree

      - render树仅保留DOM的body部分，删去display:none的部分

      > 引申：当下载css文件阻塞了会阻塞DOM树的合成和页面的展示吗？
      >
      > 答案：不会，因为DOM自带默认样式，所以没必要一定阻塞。

      - 计算每个元素的位置

   4. 生成LayerTree

      - 为每一个节点分配图层（如果一个节点没有特有图层，它会被归属于第一个拥有图层的祖先节点的图层）
        - 为拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)属性的元素提升为单独一层
        - 需要clip的地方的地方会创建图层（一般来说就是overflow）

   5. 输出绘制列表

      - 渲染引擎将图层绘制拆分成很多小的绘制指令，然后按照顺序组成一个待绘制列表
      - 绘制列表提交给**渲染引擎的合成线程**。

   6. 栅格化

      - 合成线程将图层划分为图块(tile)，通常为256×256或512×512
      - 优先将视口附近的图块生成位图（将图块生成位图的操作就是栅格化）
      - 通常栅格化过程都会用GPU加速（GPU操作是在GPU进程里进行的，栅格化好的位图放在GPU内存中）

   7. 合成和显示

      - 一旦所有图块都被栅格化之后，合成线程就会生成一个绘制图块的命令"DrawQuad"，然后将该命令提交给浏览器进程
      - 浏览器进程里的viz组件接受到DrawQuad命令，然后根据命令将页面内容绘制到内存中，然后将内存显示到桌面上

10. 等待更新

    - 重排：改变元素的几何位置属性，就会从`输出computedStyle`步骤开始完整执行
    - 重绘：更改背景色等时，也是从`输出computedStyle`步骤开始直接跳过`输出LayoutTree`和`生成LayerTree`,接着从输出绘制列表开始。
    - 直接合成：css的transform等会直接从栅格化开始。

    > 减少重排和重绘：
    >
    > - 使用class操作样式（多次变换统一）
    > - 避免使用table布局
    > - 批量DOM操作（createDocumentFragment，或者框架的VNode）
    > - dom操作读写分离
    > - will-change：transform优化（告诉浏览器哪些属性将来会发生变化）

>  **CSS阻塞**
>
>  1. css 文件的下载和解析不会影响 DOM 的解析，但是会阻塞 DOM 的渲染。
>  2. css 文件没下载并解析完成之前，后续的 js 脚本不能执行。
>  3. css 文件的下载不会阻塞前面的 js 脚本执行。
>
>  **JS阻塞**
>
>  1. js 文件没下载并解析完成之前，后续的 HTML 和 CSS 无法解析
>  2. js 文件的下载不会阻塞前面 HTML 和 CSS 的解析
>
>  **浏览器遇到script标签会进行一次页面渲染**
>
>  window.onload：当前页面所有资源加载完成之后
>
>  DOMContentLoaded：DOM树生成之后就出发该事件

